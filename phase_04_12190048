
(gdb) b phase_4
Breakpoint 1 at 0x400ffa
(gdb) r answers.txt
Starting program: /mnt/e/GCIT/Semester V/ITP304-CSI/Assignment/Assignment1/Assignment 1_2/Assignment 1/bomb003/bomb answers.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
4 2

Breakpoint 1, 0x0000000000400ffa in phase_4 ()
(gdb) disas
Dump of assembler code for function phase_4:
=> 0x0000000000400ffa <+0>:     sub    $0x18,%rsp // Makes stack frame
   0x0000000000400ffe <+4>:     mov    %fs:0x28,%rax // rax = %fs:0x28
   0x0000000000401007 <+13>:    mov    %rax,0x8(%rsp)
   0x000000000040100c <+18>:    xor    %eax,%eax // eax = eax ^ eax
   0x000000000040100e <+20>:    lea    0x4(%rsp),%rcx // rcx = rsp + 0x4
   0x0000000000401013 <+25>:    mov    %rsp,%rdx // rdx = rsp
   0x0000000000401016 <+28>:    mov    $0x4025af,%esi // input format "%d %d"
   0x000000000040101b <+33>:    callq  0x400bb0 <__isoc99_sscanf@plt> // takes %d input
   0x0000000000401020 <+38>:    cmp    $0x2,%eax 
   0x0000000000401023 <+41>:    jne    0x40102b <phase_4+49>// if(0x2 != eax) then explode bomb
   0x0000000000401025 <+43>:    cmpl   $0xe,(%rsp) 
   0x0000000000401029 <+47>:    jbe    0x401030 <phase_4+54> // if(rsp >= 0xe) then explode bomb
   0x000000000040102b <+49>:    callq  0x40142a <explode_bomb> 
   0x0000000000401030 <+54>:    mov    $0xe,%edx // edx = 0xe
   0x0000000000401035 <+59>:    mov    $0x0,%esi // esi = 0x0
   0x000000000040103a <+64>:    mov    (%rsp),%edi // edi = rsp
   0x000000000040103d <+67>:    callq  0x400fbc <func4>
   0x0000000000401042 <+72>:    cmp    $0x2,%eax
   0x0000000000401045 <+75>:    jne    0x40104e <phase_4+84> // if(eax != 0x2) then explode bomb
   0x0000000000401047 <+77>:    cmpl   $0x2,0x4(%rsp) 
   0x000000000040104c <+82>:    je     0x401053 <phase_4+89> // if(0x4+rsp != 0x2) then explode bomb
   0x000000000040104e <+84>:    callq  0x40142a <explode_bomb>
   0x0000000000401053 <+89>:    mov    0x8(%rsp),%rax // rax = rsp + 0x8
   0x0000000000401058 <+94>:    xor    %fs:0x28,%rax // rax = rax ^ fs:0x28
   0x0000000000401061 <+103>:   je     0x401068 <phase_4+110> // if(rax == 1) then jump to +105
   0x0000000000401063 <+105>:   callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000401068 <+110>:   add    $0x18,%rsp // rsp = rsp + 0x18
   0x000000000040106c <+114>:   retq // return
End of assembler dump.
(gdb) u*0x000000000040103d
0x000000000040103d in phase_4 ()
(gdb) disas
Dump of assembler code for function phase_4:
   0x0000000000400ffa <+0>:     sub    $0x18,%rsp
   0x0000000000400ffe <+4>:     mov    %fs:0x28,%rax
   0x0000000000401007 <+13>:    mov    %rax,0x8(%rsp)
   0x000000000040100c <+18>:    xor    %eax,%eax
   0x000000000040100e <+20>:    lea    0x4(%rsp),%rcx
   0x0000000000401013 <+25>:    mov    %rsp,%rdx
   0x0000000000401016 <+28>:    mov    $0x4025af,%esi
   0x000000000040101b <+33>:    callq  0x400bb0 <__isoc99_sscanf@plt>
   0x0000000000401020 <+38>:    cmp    $0x2,%eax
   0x0000000000401023 <+41>:    jne    0x40102b <phase_4+49>
   0x0000000000401025 <+43>:    cmpl   $0xe,(%rsp)
   0x0000000000401029 <+47>:    jbe    0x401030 <phase_4+54>
   0x000000000040102b <+49>:    callq  0x40142a <explode_bomb>
   0x0000000000401030 <+54>:    mov    $0xe,%edx
   0x0000000000401035 <+59>:    mov    $0x0,%esi
   0x000000000040103a <+64>:    mov    (%rsp),%edi
=> 0x000000000040103d <+67>:    callq  0x400fbc <func4>
   0x0000000000401042 <+72>:    cmp    $0x2,%eax
   0x0000000000401045 <+75>:    jne    0x40104e <phase_4+84>
   0x0000000000401047 <+77>:    cmpl   $0x2,0x4(%rsp)
   0x000000000040104c <+82>:    je     0x401053 <phase_4+89>
   0x000000000040104e <+84>:    callq  0x40142a <explode_bomb>
   0x0000000000401053 <+89>:    mov    0x8(%rsp),%rax
   0x0000000000401058 <+94>:    xor    %fs:0x28,%rax
   0x0000000000401061 <+103>:   je     0x401068 <phase_4+110>
   0x0000000000401063 <+105>:   callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000401068 <+110>:   add    $0x18,%rsp
   0x000000000040106c <+114>:   retq
End of assembler dump.
(gdb) si
0x0000000000400fbc in func4 ()
(gdb) disas
Dump of assembler code for function func4:
=> 0x0000000000400fbc <+0>:     sub    $0x8,%rsp
   0x0000000000400fc0 <+4>:     mov    %edx,%eax
   0x0000000000400fc2 <+6>:     sub    %esi,%eax
   0x0000000000400fc4 <+8>:     mov    %eax,%ecx
   0x0000000000400fc6 <+10>:    shr    $0x1f,%ecx
   0x0000000000400fc9 <+13>:    add    %ecx,%eax
   0x0000000000400fcb <+15>:    sar    %eax
   0x0000000000400fcd <+17>:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fd0 <+20>:    cmp    %edi,%ecx
   0x0000000000400fd2 <+22>:    jle    0x400fe0 <func4+36>
   0x0000000000400fd4 <+24>:    lea    -0x1(%rcx),%edx
   0x0000000000400fd7 <+27>:    callq  0x400fbc <func4>
   0x0000000000400fdc <+32>:    add    %eax,%eax
   0x0000000000400fde <+34>:    jmp    0x400ff5 <func4+57>
   0x0000000000400fe0 <+36>:    mov    $0x0,%eax
   0x0000000000400fe5 <+41>:    cmp    %edi,%ecx
   0x0000000000400fe7 <+43>:    jge    0x400ff5 <func4+57>
   0x0000000000400fe9 <+45>:    lea    0x1(%rcx),%esi
   0x0000000000400fec <+48>:    callq  0x400fbc <func4>
   0x0000000000400ff1 <+53>:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000400ff5 <+57>:    add    $0x8,%rsp
   0x0000000000400ff9 <+61>:    retq
End of assembler dump.
(gdb) ni
0x0000000000400fc0 in func4 ()
(gdb) i r
rax            0x2                 2
rbx            0x7ffffffee138      140737488281912
rcx            0x0                 0
rdx            0xe                 14
rsi            0x0                 0
rdi            0x4                 4
rbp            0x0                 0x0
rsp            0x7ffffffee010      0x7ffffffee010
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7fffff74eac0      140737479240384
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7ffffffee130      140737488281904
r14            0x0                 0
r15            0x0                 0
rip            0x400fc0            0x400fc0 <func4+4>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) disas
Dump of assembler code for function func4:
   0x0000000000400fbc <+0>:     sub    $0x8,%rsp // makes stack frame
   0x0000000000400fc0 <+4>:     mov    %edx,%eax // eax = edx
   0x0000000000400fc2 <+6>:     sub    %esi,%eax // eax = eax - esi
=> 0x0000000000400fc4 <+8>:     mov    %eax,%ecx // ecx = eax
   0x0000000000400fc6 <+10>:    shr    $0x1f,%ecx // ecx = returns most significant digit --> 0
   0x0000000000400fc9 <+13>:    add    %ecx,%eax // eax = eax + ecx
   0x0000000000400fcb <+15>:    sar    %eax // eax = eax / 2
   0x0000000000400fcd <+17>:    lea    (%rax,%rsi,1),%ecx // ecx = rax + rsi + 1
   0x0000000000400fd0 <+20>:    cmp    %edi,%ecx
   0x0000000000400fd2 <+22>:    jle    0x400fe0 <func4+36> // if(ecx <= edi) then goto func4+36
   0x0000000000400fd4 <+24>:    lea    -0x1(%rcx),%edx // edx = rcx - 0x1
   0x0000000000400fd7 <+27>:    callq  0x400fbc <func4> // function call 
   0x0000000000400fdc <+32>:    add    %eax,%eax // eax = eax + eax
   0x0000000000400fde <+34>:    jmp    0x400ff5 <func4+57> // jump to func4+57
   0x0000000000400fe0 <+36>:    mov    $0x0,%eax // eax = 0x0
   0x0000000000400fe5 <+41>:    cmp    %edi,%ecx
   0x0000000000400fe7 <+43>:    jge    0x400ff5 <func4+57> // if(ecx >= edi) then func4+57
   0x0000000000400fe9 <+45>:    lea    0x1(%rcx),%esi // esi = rcx + 0x1
   0x0000000000400fec <+48>:    callq  0x400fbc <func4>
   0x0000000000400ff1 <+53>:    lea    0x1(%rax,%rax,1),%eax // eax = rax+ 1 + rax + 0x1
   0x0000000000400ff5 <+57>:    add    $0x8,%rsp // rsp = rsp + 0x8
   0x0000000000400ff9 <+61>:    retq   // return
End of assembler dump.
(gdb) i r
rax            0xe                 14
rbx            0x7ffffffee138      140737488281912
rcx            0x0                 0
rdx            0xe                 14
rsi            0x0                 0
rdi            0x4                 4
rbp            0x0                 0x0
rsp            0x7ffffffee010      0x7ffffffee010
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7fffff74eac0      140737479240384
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7ffffffee130      140737488281904
r14            0x0                 0
r15            0x0                 0
rip            0x400fc4            0x400fc4 <func4+8>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
Dump of assembler code for function phase_4:
   0x0000000000400ffa <+0>:     sub    $0x18,%rsp
   0x0000000000400ffe <+4>:     mov    %fs:0x28,%rax
   0x0000000000401007 <+13>:    mov    %rax,0x8(%rsp)
   0x000000000040100c <+18>:    xor    %eax,%eax
   0x000000000040100e <+20>:    lea    0x4(%rsp),%rcx
   0x0000000000401013 <+25>:    mov    %rsp,%rdx
   0x0000000000401016 <+28>:    mov    $0x4025af,%esi
   0x000000000040101b <+33>:    callq  0x400bb0 <__isoc99_sscanf@plt>
   0x0000000000401020 <+38>:    cmp    $0x2,%eax
   0x0000000000401023 <+41>:    jne    0x40102b <phase_4+49>
   0x0000000000401025 <+43>:    cmpl   $0xe,(%rsp)
   0x0000000000401029 <+47>:    jbe    0x401030 <phase_4+54>
   0x000000000040102b <+49>:    callq  0x40142a <explode_bomb>
   0x0000000000401030 <+54>:    mov    $0xe,%edx
   0x0000000000401035 <+59>:    mov    $0x0,%esi
   0x000000000040103a <+64>:    mov    (%rsp),%edi
   0x000000000040103d <+67>:    callq  0x400fbc <func4>
   0x0000000000401042 <+72>:    cmp    $0x2,%eax
   0x0000000000401045 <+75>:    jne    0x40104e <phase_4+84>
=> 0x0000000000401047 <+77>:    cmpl   $0x2,0x4(%rsp)
   0x000000000040104c <+82>:    je     0x401053 <phase_4+89>
   0x000000000040104e <+84>:    callq  0x40142a <explode_bomb>
   0x0000000000401053 <+89>:    mov    0x8(%rsp),%rax
   0x0000000000401058 <+94>:    xor    %fs:0x28,%rax
   0x0000000000401061 <+103>:   je     0x401068 <phase_4+110>
   0x0000000000401063 <+105>:   callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000401068 <+110>:   add    $0x18,%rsp
   0x000000000040106c <+114>:   retq
End of assembler dump.
(gdb) p/x *(int*)($rsp+0x4)
$1 = 0x2
(gdb) u*0x000000000040106c
main (argc=<optimized out>, argv=<optimized out>) at bomb.c:96
96          phase_defused();
(gdb) quit
A debugging session is active.

        Inferior 1 [process 69] will be killed.

Quit anyway? (y or n) y


Termination

After several testing and go through condition in the code, we understand that it takes two interger input and first input should be between 2 to 14.In this 
phase it deals with the recursion in function 4(func4()). After going  through this recursion, we came to conclusion that it should return value 2 such that 
it will meet the condition which help in defusing the bomb.We also got that out last inputs need to be 2 inorder not to explode the bomb.After visiting all
the conditions, we came to know first input should be  2 to 14 and  second  should be 2. So after checking all the numbers from 2 to 14,  4 was correct digit
for first input.

Therefore to defuse phase 4, user input is "4 2"
